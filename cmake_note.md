```
Author:lgx
Date:2022.08.15 16:54:58
Email:geniuslgx@mail.ustc.edu.com
```

# 0. 各种关系

## 0.1 编译的4阶段

> 0. **编写**
>
>    > 用编辑器编写.c、.h、.cpp等文件
>
> 1. **预处理**
>
> >  - 处理所有预编译指令，如：#define、#include、#if、#elif、#else等
> >  - 删除所有注释
> >  - 生成.i文件
> >  - `gcc -E main.c -o main.i`
> 2. **编译**
>
> > - 高级语言（C/C++）----->中间代码（汇编语言）
> > - 扫码、语法分析、语义分析、源代码分析、目标代码生成、目标代码优化、符号汇总
> > - 生成.s文件
> > - `gcc -S main.i -o main.s`
>
> 3. **汇编**
>
> > - 中间代码（汇编语言）----->目标文件（二进制文件）
> >
> > - 根据汇编指令和特定平台，把汇编指令翻译成二进制形式
> > - 生成.o文件
> > - `gcc -c main.s -o main.o`
>
> 4. **链接**
>
>    > - 多个目标文件（二进制文件）结合库函数等。合成的能直接独立执行的执行文件
>    > - 输出.out(.exe)文件

## 0.1 gcc vs g++

> **GCC和gcc是不同的东西**
>
> **GCC**:GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、Fortran、Pascal等语言
>
> **gcc**与**g++**都是是其中的一个子集，都是一个**编译器**
>
> ||gcc|g++|
> |:-:|:-:|:-:|
> |编译|.c后缀当作c程序|.c后缀文件当作cpp程序|
> |链接|不能自动和C++程序使用的库链接|自动和C++程序使用的库链接|

## 0.2 gcc(g++) vs make

> ||gcc|make|
> |:-:|:-:|:-:|
> |本质|编译器|命令工具|
> |用途|编译**1个**源文件|基于**makefile**，编译**多个**源文件|
> |关系|被调用|在makefile中调用gcc/g++|

## 0.3 make vs cmake

>|          |                       make                        |        cmake         |
>| :------: | :-----------------------------------------------: | :------------------: |
>| 产生原因 | 当存在多个源文件时，用gcc逐个编译，工作量大且复杂 | 编写makefile文件复杂 |
>|   输入   |                     makefile                      |    CMakeLists.txt    |
>|   输出   |                    可执行文件                     |       makefile       |
>
>一图胜千言：
>
>![cmake和make的区别](./images/cmake&make.jpg 'cmake和make的区别')

## 0.4 动态库 vs 静态库

> |      |                  动态库                  |                    静态库                    |
> | :--: | :--------------------------------------: | :------------------------------------------: |
> | 后缀 |               .so 或 .dll                |                  .a 或 .lib                  |
> | 优点 | 目标程序较小，且可以动态更换指定的依赖库 | 直接整合到目标程序中，目标程序可**独立运行** |
> | 缺点 |           目标程序不可独立执行           |    目标程序较大，且升级时需要**重新编译**    |

# 1. g++(gcc)

## 1.1 安装

> ``` 
> apt install g++ gcc
> ```

## 1.2 基本流程

> - `g++ main.cpp -o main.out` 等价于以下命令
>   - 预处理生成.i文件（消去注释等）：`g++ -E main.cpp -o main.i`
>   - 编译生成.s文件（汇编语言）：`g++ -S main.i -o main.s`
>   - 汇编生气.o文件（二进制）`g++ -c main.s -o main.o`
>   - 链接生成.out文件（可执行文件）`g++ main.o -o main.out`

## 1.3 重要参数

>- -g 编译带调试信息的可执行文件
>
>  > -g选项告诉g++产生能被GNU调试器gdb使用的调试信息，以调试程序
>  >
>  > 如：`g++ -g main.cpp -o main`
>
>- -O[n] 优化源代码
>
>  > 优化：例如省略掉源代码中未使用过的变量、常量表达式直接用其结果表示等，会缩减代码量，从而提高运行效率
>  >
>  > O0：不优化
>  >
>  > O1：默认优化
>  >
>  > O2：完成O1优化外，还完成指令调整等。
>  >
>  > O3：包括循环展开和一些与处理特性相关的优化工作
>  >
>  > 优化等级越高，编译越慢，编译得到的可执行程序效率越高，通常使用**O2**优化
>  >
>  > 如：`g++ -O2 main.cpp -o main`
>
>- -l 与 -L 指定库文件和指定库目录
>
>  > -l （L的小写）指定库名，库名**紧跟着**-l
>  >
>  > 如：`g++ -lglob main.cpp`
>  >
>  > 若系统默认的库目录中（/lib、/usr/lib和/usr/local/lib）没有指定的库，则需要-L来指定其库目录
>  >
>  > 如：`g++ -L/home/mylibfolder/ -lmylib main.cpp -o main	 `
>
>- -I 指定头文件搜索目录
>
>  > 若头文件在`/usr/include/`下，则不用指定；若不在，则需要用-I（i的大写）来指定
>  >
>  > 如：`g++ -I/myinclude main.cpp`
>
>- -Wall -w 警告信息
>
>  > -Wall 打印警告信息 如：`g++ -Wall main.cpp`
>  >
>  > -w关闭警告信息 如：`g++ -w main.cpp`，默认是关闭的
>
>- -std 编译标准
>
>  > 设置编译标准，默认标准试编译器（g++版本）而定
>  >
>  > 如：`g++ -std=c++11 main.cpp`
>
>- -D 激活宏
>
>  > 编译后，激活指定宏名
>  >
>  > ```c++
>  > #include<iostream>
>  > int main(){
>  > 	#ifdef DEBUG
>  > 		std::cout<<"debug"<<std::endl;
>  > 	#endif
>  > 	return 0;
>  > }
>  > ```
>  >
>  > 如：`g++ -DDEBUG main.cpp -o main`后执行`./main`会输出，debug
>  >
>  > 而`g++  main.cpp -o main`后执行./main，不会输出debug
